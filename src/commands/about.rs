use crate::config::AppState;
use crate::utils::{format_duration, get_default_embed_color};
use anyhow::Result;
use lazy_static::lazy_static;
use poise::serenity_prelude as serenity;
use serenity::CreateEmbed;
use std::time::SystemTime;
use sysinfo::System;

lazy_static! {
    pub static ref BOT_START_TIME: SystemTime = SystemTime::now();
}

type Error = Box<dyn std::error::Error + Send + Sync>;
type Context<'a> = poise::Context<'a, AppState, Error>;

#[poise::command(slash_command, subcommands("bot", "server", "user", "role", "channel"))]
pub async fn about(_ctx: Context<'_>) -> Result<(), Error> {
    Ok(())
}

#[poise::command(slash_command)]
pub async fn bot(ctx: Context<'_>) -> Result<(), Error> {
    let uptime = BOT_START_TIME.elapsed().unwrap_or_default();
    let uptime_str = format_duration(uptime.as_secs());
    let bot_version = env!("CARGO_PKG_VERSION");

    let start = std::time::Instant::now();
    let _ = ctx.http().get_current_user().await;
    let api_latency = start.elapsed();

    let start = std::time::Instant::now();
    let _ = ctx.ping().await;
    let gateway_latency = start.elapsed();

    let mut sys = System::new_all();
    sys.refresh_all();

    let total_memory = sys.total_memory() / 1024 / 1024;
    let used_memory = sys.used_memory() / 1024 / 1024;
    let available_memory = sys.available_memory() / 1024 / 1024;
    let memory_percentage = (used_memory as f64 / total_memory as f64) * 100.0;

    let cpu_count = sys.cpus().len();
    let cpu_usage = sys.global_cpu_usage();

    let current_pid = std::process::id();

    let guild_count = ctx.cache().guild_count();
    let cached_users = ctx.cache().user_count();

    let mut cached_channels = 0;
    for guild_id in ctx.cache().guilds() {
        if let Some(guild) = ctx.cache().guild(guild_id) {
            cached_channels += guild.channels.len();
        }
    }

    let bot_user = ctx.http().get_current_user().await?;

    let db = &ctx.data().db;

    let selfrole_configs = sqlx::query_scalar::<_, i64>("SELECT COUNT(*) FROM selfrole_configs")
        .fetch_one(db.as_ref())
        .await
        .unwrap_or_else(|_| 0);

    let selfrole_roles = sqlx::query_scalar::<_, i64>("SELECT COUNT(*) FROM selfrole_roles")
        .fetch_one(db.as_ref())
        .await
        .unwrap_or_else(|_| 0);

    let active_cooldowns = sqlx::query_scalar::<_, i64>(
        "SELECT COUNT(*) FROM selfrole_cooldowns WHERE expires_at > datetime('now')",
    )
    .fetch_one(db.as_ref())
    .await
    .unwrap_or_else(|_| 0);

    let db_guilds =
        sqlx::query_scalar::<_, i64>("SELECT COUNT(DISTINCT guild_id) FROM selfrole_configs")
            .fetch_one(db.as_ref())
            .await
            .unwrap_or_else(|_| 0);

    let recent_configs = sqlx::query_scalar::<_, i64>(
        "SELECT COUNT(*) FROM selfrole_configs WHERE created_at > datetime('now', '-7 days')",
    )
    .fetch_one(db.as_ref())
    .await
    .unwrap_or_else(|_| 0);

    let expired_cooldowns = sqlx::query_scalar::<_, i64>(
        "SELECT COUNT(*) FROM selfrole_cooldowns WHERE expires_at <= datetime('now')",
    )
    .fetch_one(db.as_ref())
    .await
    .unwrap_or_else(|_| 0);

    let db_stats = format!(
        "configs: **`{}`**
        roles: **`{}`**
        active cooldowns: **`{}`**
        servers: **`{}`**
        recent (7d): **`{}`**
        expired: **`{}`**",
        selfrole_configs,
        selfrole_roles,
        active_cooldowns,
        db_guilds,
        recent_configs,
        expired_cooldowns
    );

    let os_info = format!(
        "{} {}",
        System::name().unwrap_or_else(|| "Unknown".to_string()),
        System::os_version().unwrap_or_else(|| "Unknown".to_string())
    );
    let kernel_version = System::kernel_version().unwrap_or_else(|| "Unknown".to_string());

    let embed = CreateEmbed::new()
        .title("ü§ñ system info")
        .description(format!(
            "<@{}> `{}`
            v{}",
            bot_user.id, bot_user.id, bot_version
        ))
        .color(get_default_embed_color(ctx.data()))
        .thumbnail(bot_user.face())
        .field(
            "‚ö° performance",
            format!(
                "uptime: **`{}`**
                api: **`{}ms`**
                gateway: **`{}ms`**",
                uptime_str,
                api_latency.as_millis(),
                gateway_latency.as_millis()
            ),
            true,
        )
        .field(
            "üìä discord stats",
            format!(
                "servers: **`{}`**
                **üóÉÔ∏è cached:**
                users: **`{}`**
                channels: **`{}`**",
                guild_count, cached_users, cached_channels
            ),
            true,
        )
        .field("üóÑÔ∏è database", db_stats, true)
        .field(
            "‚öôÔ∏è CPU",
            format!(
                "usage: **{:.1}%**
                cores: **`{}`**
                arch: **`{}`**",
                cpu_usage,
                cpu_count,
                std::env::consts::ARCH
            ),
            true,
        )
        .field(
            "üíæ memory",
            format!(
                "used: **{:.1}% ({}MB)**
                free: **{:.3}MB**
                total: **{:.3}MB**",
                memory_percentage, used_memory, available_memory, total_memory
            ),
            true,
        )
        .field(
            "üñ•Ô∏è system",
            format!(
                "**`{}`**
                **`{}`**
                bot pid: **`{}`**",
                os_info, kernel_version, current_pid
            ),
            true,
        )
        .field(
            "üì¶ build info",
            format!(
                "**Rust** (Serenity + Poise)
                arch: **`{}`**",
                std::env::consts::ARCH
            ),
            true,
        )
        .field(
            "üë®‚Äçüíª vibecoder",
            "the retard in question: **[uwuclxdy](https://github.com/uwuclxdy)**
            ts bot is FOSS btw: **[clouder](https://github.com/uwuclxdy/clouder)**
            **Claude 4 Sonnet <3**",
            true,
        )
        .timestamp(serenity::Timestamp::now());

    ctx.send(poise::CreateReply::default().embed(embed)).await?;
    Ok(())
}

#[poise::command(slash_command)]
pub async fn server(ctx: Context<'_>) -> Result<(), Error> {
    let guild_id = match ctx.guild_id() {
        Some(id) => id,
        None => {
            ctx.send(
                poise::CreateReply::default()
                    .content("‚ùå this command can only be used in a server!")
                    .ephemeral(true),
            )
            .await?;
            return Ok(());
        }
    };

    let full_guild = match ctx.http().get_guild_with_counts(guild_id).await {
        Ok(guild) => guild,
        Err(_) => match ctx.http().get_guild(guild_id).await {
            Ok(guild) => guild,
            Err(_) => {
                ctx.send(
                    poise::CreateReply::default()
                        .content("‚ùå failed to fetch server info!")
                        .ephemeral(true),
                )
                .await?;
                return Ok(());
            }
        },
    };

    let member_count = match full_guild.approximate_member_count {
        Some(count) => count,
        None => match ctx.guild() {
            Some(guild) => guild.member_count,
            None => 0,
        },
    };

    let created_at = guild_id.created_at();
    let created_timestamp = format!("<t:{}:F>", created_at.timestamp());

    let channels = if let Ok(channels) = full_guild.channels(&ctx.http()).await {
        channels
    } else {
        std::collections::HashMap::new()
    };

    let text_channels = channels
        .values()
        .filter(|c| matches!(c.kind, serenity::ChannelType::Text))
        .count();
    let voice_channels = channels
        .values()
        .filter(|c| matches!(c.kind, serenity::ChannelType::Voice))
        .count();
    let stage_channels = channels
        .values()
        .filter(|c| matches!(c.kind, serenity::ChannelType::Stage))
        .count();
    let forum_channels = channels
        .values()
        .filter(|c| matches!(c.kind, serenity::ChannelType::Forum))
        .count();
    let category_channels = channels
        .values()
        .filter(|c| matches!(c.kind, serenity::ChannelType::Category))
        .count();
    let total_channels = channels.len();

    let role_count = full_guild.roles.len();
    let emoji_count = full_guild.emojis.len();
    let sticker_count = full_guild.stickers.len();

    let boost_level = match full_guild.premium_tier {
        serenity::PremiumTier::Tier0 => 0,
        serenity::PremiumTier::Tier1 => 1,
        serenity::PremiumTier::Tier2 => 2,
        serenity::PremiumTier::Tier3 => 3,
        _ => 0,
    };
    let boost_count = full_guild.premium_subscription_count.unwrap_or(0);

    let owner = match full_guild.owner_id.to_user(&ctx.http()).await {
        Ok(user) => format!("<@{}> `{}`", user.id, user.id),
        Err(_) => format!("unknown (`{}`)", full_guild.owner_id),
    };

    let verification_level = match full_guild.verification_level {
        serenity::VerificationLevel::None => "None",
        serenity::VerificationLevel::Low => "Low",
        serenity::VerificationLevel::Medium => "Medium",
        serenity::VerificationLevel::High => "High",
        serenity::VerificationLevel::Higher => "Highest",
        _ => "Unknown",
    };

    let explicit_filter = format!("{:?}", full_guild.explicit_content_filter);

    let notification_level = format!("{:?}", full_guild.default_message_notifications);

    let mut features = Vec::new();
    for feature in &full_guild.features {
        let feature_str = match feature.as_str() {
            "COMMUNITY" => "üèõÔ∏è Community",
            "PARTNERED" => "ü§ù Partnered",
            "VERIFIED" => "‚úÖ Verified",
            "DISCOVERABLE" => "üîç Discoverable",
            "VANITY_URL" => "üîó Vanity URL",
            "BANNER" => "üñºÔ∏è Banner",
            "ANIMATED_BANNER" => "üé¨ Animated Banner",
            "INVITE_SPLASH" => "üåä Invite Splash",
            "VIP_REGIONS" => "üëë VIP Voice Regions",
            "WELCOME_SCREEN_ENABLED" => "üëã Welcome Screen",
            "THREADS_ENABLED" => "üßµ Threads",
            "PRIVATE_THREADS" => "üîí Private Threads",
            "ROLE_ICONS" => "üè∑Ô∏è Role Icons",
            "NEWS" => "üì∞ News Channels",
            "PUBLIC" => "üåê Public",
            "MONETIZATION_ENABLED" => "üí∞ Monetized",
            _ => continue,
        };
        features.push(feature_str);
    }

    let mut embed = CreateEmbed::new()
        .title(&format!("üìä `{}` info", full_guild.name))
        .color(get_default_embed_color(ctx.data()))
        .field("üë• members", format!("**`{member_count}`**"), true);

    if let Some(approximate_presence_count) = full_guild.approximate_presence_count {
        embed = embed.field(
            "üü¢ online",
            format!("**~`{}`**", approximate_presence_count),
            true,
        );
    }

    if let Some(description) = &full_guild.description {
        if !description.is_empty() {
            embed = embed.field("üìù description", format!("*{}*", description), false);
        }
    }

    let channel_breakdown = if stage_channels > 0 || forum_channels > 0 {
        format!(
            "**`{total_channels}`** total\nüìù **`{text_channels}`** text\nüîä **`{voice_channels}`** voice\nüéôÔ∏è **`{stage_channels}`** stage\nüí¨ **`{forum_channels}`** forum\nüìÅ **`{category_channels}`** categories"
        )
    } else {
        format!(
            "**`{total_channels}`** total\nüìù **`{text_channels}`** text\nüîä **`{voice_channels}`** voice\nüìÅ **`{category_channels}`** categories"
        )
    };

    embed = embed.field("üí¨ channels", channel_breakdown, true).field(
        "üé≠ roles",
        format!("**`{role_count}`**"),
        true,
    );

    if emoji_count > 0 || sticker_count > 0 {
        embed = embed.field(
            "üòÄ emojis & stickers",
            format!("emojis: **`{emoji_count}`**\nstickers: **`{sticker_count}`**"),
            true,
        );
    }

    embed = embed
        .field("üëë owner", owner, false)
        .field("üìÖ created", created_timestamp, false)
        .field(
            "üöÄ boost level",
            format!("boosts: **`{boost_count}`**\nlevel: **`{boost_level}`**"),
            true,
        );

    if let Some(vanity_url) = &full_guild.vanity_url_code {
        embed = embed.field(
            "üîó vanity url",
            format!("**discord.gg/{}**", vanity_url),
            true,
        );
    }

    embed = embed.field(
        "üõ°Ô∏è security",
        format!(
            "verification: **{}**\nfilter: **{}**\nnotifications: **{}**",
            verification_level, explicit_filter, notification_level
        ),
        true,
    );

    if !features.is_empty() && features.len() <= 6 {
        embed = embed.field("‚ú® features", features.join(" "), false);
    }

    if let Some(max_members) = full_guild.max_members {
        embed = embed.field("üë• max members", format!("**`{}`**", max_members), true);
    }

    if let Some(max_presences) = full_guild.max_presences {
        embed = embed.field("üü¢ max presences", format!("**`{}`**", max_presences), true);
    }

    if let Some(max_video_channel_users) = full_guild.max_video_channel_users {
        embed = embed.field(
            "üé• max video users",
            format!("**`{}`**", max_video_channel_users),
            true,
        );
    }

    if let Some(max_stage_video_channel_users) = full_guild.max_stage_video_channel_users {
        embed = embed.field(
            "üé§ max stage users",
            format!("**`{}`**", max_stage_video_channel_users),
            true,
        );
    }

    if let Some(widget_enabled) = full_guild.widget_enabled {
        if widget_enabled {
            embed = embed.field("üõ†Ô∏è widget enabled", "**yes**", true);
            if let Some(widget_channel_id) = full_guild.widget_channel_id {
                embed = embed.field(
                    "üõ†Ô∏è widget channel",
                    format!("<#{}>", widget_channel_id),
                    true,
                );
            }
        }
    }

    if let Some(application_id) = full_guild.application_id {
        embed = embed.field("ü§ñ created by app", format!("`{}`", application_id), true);
    }

    if let Some(system_channel_id) = full_guild.system_channel_id {
        embed = embed.field(
            "üì® system channel",
            format!("<#{}>", system_channel_id),
            true,
        );

        let system_flags = full_guild.system_channel_flags;
        let mut suppressed = Vec::new();
        if system_flags.contains(serenity::SystemChannelFlags::SUPPRESS_JOIN_NOTIFICATIONS) {
            suppressed.push("join messages");
        }
        if system_flags.contains(serenity::SystemChannelFlags::SUPPRESS_PREMIUM_SUBSCRIPTIONS) {
            suppressed.push("boost messages");
        }
        if system_flags
            .contains(serenity::SystemChannelFlags::SUPPRESS_GUILD_REMINDER_NOTIFICATIONS)
        {
            suppressed.push("setup tips");
        }
        if system_flags.contains(serenity::SystemChannelFlags::SUPPRESS_JOIN_NOTIFICATION_REPLIES) {
            suppressed.push("join replies");
        }
        if system_flags.contains(
            serenity::SystemChannelFlags::SUPPRESS_ROLE_SUBSCRIPTION_PURCHASE_NOTIFICATIONS,
        ) {
            suppressed.push("role subscription purchases");
        }
        if system_flags.contains(
            serenity::SystemChannelFlags::SUPPRESS_ROLE_SUBSCRIPTION_PURCHASE_NOTIFICATION_REPLIES,
        ) {
            suppressed.push("role subscription replies");
        }

        if !suppressed.is_empty() {
            embed = embed.field("üîá suppressed", suppressed.join(", "), true);
        }
    }

    if let Some(rules_channel_id) = full_guild.rules_channel_id {
        embed = embed.field("üìú rules channel", format!("<#{}>", rules_channel_id), true);
    }

    if let Some(public_updates_channel_id) = full_guild.public_updates_channel_id {
        embed = embed.field(
            "üì¢ updates channel",
            format!("<#{}>", public_updates_channel_id),
            true,
        );
    }

    let mfa_level = match full_guild.mfa_level {
        serenity::MfaLevel::None => "None",
        serenity::MfaLevel::Elevated => "Elevated (2FA required)",
        _ => "Unknown",
    };
    embed = embed.field("üîê 2FA requirement", format!("**{}**", mfa_level), true);

    let nsfw_level = match full_guild.nsfw_level {
        serenity::NsfwLevel::Default => "Default",
        serenity::NsfwLevel::Explicit => "Explicit",
        serenity::NsfwLevel::Safe => "Safe",
        serenity::NsfwLevel::AgeRestricted => "Age Restricted",
        _ => "Unknown",
    };
    embed = embed.field("üîû NSFW level", format!("**{}**", nsfw_level), true);

    embed = embed.field(
        "üåç locale",
        format!("**`{}`**", full_guild.preferred_locale),
        true,
    );

    if full_guild.premium_progress_bar_enabled {
        embed = embed.field("üü£ progress bar", "**enabled**", true);
    }

    embed = embed.field("üè∑Ô∏è server id", format!("**`{guild_id}`**"), true);

    if let Some(afk_metadata) = &full_guild.afk_metadata {
        embed = embed.field(
            "üò¥ AFK channel",
            format!("<#{}>", afk_metadata.afk_channel_id),
            true,
        );
        let timeout_secs = match afk_metadata.afk_timeout {
            serenity::AfkTimeout::OneMinute => 60,
            serenity::AfkTimeout::FiveMinutes => 300,
            serenity::AfkTimeout::FifteenMinutes => 900,
            serenity::AfkTimeout::ThirtyMinutes => 1800,
            serenity::AfkTimeout::OneHour => 3600,
            _ => 0,
        };
        if timeout_secs > 0 {
            embed = embed.field(
                "‚è±Ô∏è AFK timeout",
                format!("**{}min**", timeout_secs / 60),
                true,
            );
        }
    }

    if let Some(welcome_screen) = &full_guild.welcome_screen {
        if let Some(description) = &welcome_screen.description {
            if !description.is_empty() {
                embed = embed.field(
                    "üëã welcome description",
                    format!("*{}*", description),
                    false,
                );
            }
        }
    }

    if let Some(discovery_splash) = &full_guild.discovery_splash {
        let discovery_splash_url = format!(
            "https://cdn.discordapp.com/discovery-splashes/{}/{}.png",
            guild_id, discovery_splash
        );
        embed = embed.field(
            "üîç discovery splash",
            format!("[View Image]({})", discovery_splash_url),
            true,
        );
    }

    if let Some(splash) = &full_guild.splash {
        let splash_url = format!(
            "https://cdn.discordapp.com/splashes/{}/{}.png",
            guild_id, splash
        );
        embed = embed.field(
            "üåä invite splash",
            format!("[View Image]({})", splash_url),
            true,
        );
    }

    if let Some(icon_hash) = &full_guild.icon_hash {
        embed = embed.field("üÜî icon hash", format!("`{}`", icon_hash), true);
    }

    if let Some(icon_url) = full_guild.icon_url() {
        embed = embed.thumbnail(icon_url);
    }

    if let Some(banner_url) = full_guild.banner_url() {
        embed = embed.image(banner_url);
    }

    embed = embed.timestamp(serenity::Timestamp::now());

    ctx.send(poise::CreateReply::default().embed(embed)).await?;
    Ok(())
}

#[poise::command(slash_command)]
pub async fn user(
    ctx: Context<'_>,
    #[description = "User to get information about"] user: Option<serenity::User>,
) -> Result<(), Error> {
    let target_user = user.unwrap_or_else(|| ctx.author().clone());

    let member_info = if let Some(guild_id) = ctx.guild_id() {
        match guild_id.member(&ctx.http(), target_user.id).await {
            Ok(member) => Some(member),
            Err(_) => None,
        }
    } else {
        None
    };

    let full_user = ctx
        .http()
        .get_user(target_user.id)
        .await
        .unwrap_or(target_user.clone());

    let created_at = target_user.id.created_at();
    let account_age = format!(
        "<t:{}:F> (<t:{}:R>)",
        created_at.timestamp(),
        created_at.timestamp()
    );

    let display_name = if let Some(global_name) = &full_user.global_name {
        format!("**`{}`** (global name)", global_name)
    } else {
        format!("**`{}`**", target_user.display_name().to_string())
    };

    let mut embed = CreateEmbed::new()
        .color(get_default_embed_color(ctx.data()))
        .title(&format!("üë§ `{}` info", target_user.tag()))
        .description(format!(
            "<@{}> `{}`",
            target_user.id,
            target_user.id.to_string()
        ))
        .field("‚úçÔ∏è display name", display_name, true)
        .field("üìÖ account created", account_age, false);

    if let Some(discriminator) = target_user.discriminator {
        embed = embed.field(
            "üè∑Ô∏è discriminator",
            format!("**`#{:04}`**", discriminator),
            true,
        );
    }

    if target_user.bot {
        embed = embed.field("ü§ñ bot", "yes", true);
    }

    if target_user.system {
        embed = embed.field("‚öôÔ∏è system user", "yes", true);
    }

    if let Some(locale) = &full_user.locale {
        embed = embed.field("üåç locale", format!("**`{}`**", locale), true);
    }

    if let Some(verified) = full_user.verified {
        embed = embed.field(
            "‚úÖ email verified",
            if verified { "**yes**" } else { "**no**" },
            true,
        );
    }

    if let Some(email) = &full_user.email {
        if !email.is_empty() {
            embed = embed.field("üìß email", format!("**`{}`**", email), true);
        }
    }

    if full_user.mfa_enabled {
        embed = embed.field("üîê 2FA enabled", "**yes**", true);
    }

    let flags = full_user.flags;
    if !flags.is_empty() {
        let mut private_flags = Vec::new();

        if flags.contains(serenity::UserPublicFlags::DISCORD_EMPLOYEE) {
            private_flags.push("üõ°Ô∏è Staff");
        }
        if flags.contains(serenity::UserPublicFlags::PARTNERED_SERVER_OWNER) {
            private_flags.push("ü§ù Partner");
        }
        if flags.contains(serenity::UserPublicFlags::HYPESQUAD_EVENTS) {
            private_flags.push("‚ö° HypeSquad");
        }
        if flags.contains(serenity::UserPublicFlags::BUG_HUNTER_LEVEL_1) {
            private_flags.push("üêõ Bug Hunter L1");
        }
        if flags.contains(serenity::UserPublicFlags::BUG_HUNTER_LEVEL_2) {
            private_flags.push("üêõ Bug Hunter L2");
        }
        if flags.contains(serenity::UserPublicFlags::EARLY_VERIFIED_BOT_DEVELOPER) {
            private_flags.push("üîß Verified Dev");
        }
        if flags.contains(serenity::UserPublicFlags::DISCORD_CERTIFIED_MODERATOR) {
            private_flags.push("üõ°Ô∏è Cert. Mod");
        }

        if !private_flags.is_empty() {
            embed = embed.field("üîí user flags", private_flags.join(" "), false);
        }
    }

    let user_flags = target_user.public_flags.unwrap_or_default();
    let mut badges = Vec::new();

    if user_flags.contains(serenity::UserPublicFlags::DISCORD_EMPLOYEE) {
        badges.push("üõ°Ô∏è Staff");
    }
    if user_flags.contains(serenity::UserPublicFlags::PARTNERED_SERVER_OWNER) {
        badges.push("ü§ù Partner");
    }
    if user_flags.contains(serenity::UserPublicFlags::HYPESQUAD_EVENTS) {
        badges.push("‚ö° HypeSquad Events");
    }
    if user_flags.contains(serenity::UserPublicFlags::BUG_HUNTER_LEVEL_1) {
        badges.push("üêõ Bug Hunter");
    }
    if user_flags.contains(serenity::UserPublicFlags::BUG_HUNTER_LEVEL_2) {
        badges.push("üêõ Bug Hunter Gold");
    }
    if user_flags.contains(serenity::UserPublicFlags::HOUSE_BRAVERY) {
        badges.push("ü¶Å HypeSquad Bravery");
    }
    if user_flags.contains(serenity::UserPublicFlags::HOUSE_BRILLIANCE) {
        badges.push("üíé HypeSquad Brilliance");
    }
    if user_flags.contains(serenity::UserPublicFlags::HOUSE_BALANCE) {
        badges.push("‚öñÔ∏è HypeSquad Balance");
    }
    if user_flags.contains(serenity::UserPublicFlags::EARLY_SUPPORTER) {
        badges.push("üéâ Early Supporter");
    }
    if user_flags.contains(serenity::UserPublicFlags::EARLY_VERIFIED_BOT_DEVELOPER) {
        badges.push("üîß Verified Bot Developer");
    }
    if user_flags.contains(serenity::UserPublicFlags::DISCORD_CERTIFIED_MODERATOR) {
        badges.push("üõ°Ô∏è Certified Moderator");
    }
    if user_flags.contains(serenity::UserPublicFlags::ACTIVE_DEVELOPER) {
        badges.push("‚ö° Active Developer");
    }

    if !badges.is_empty() {
        embed = embed.field("üèÜ badges", badges.join(" "), false);
    }

    if full_user.premium_type != serenity::PremiumType::None {
        let nitro_type = match full_user.premium_type {
            serenity::PremiumType::Nitro => "üíé Discord Nitro",
            serenity::PremiumType::NitroClassic => "üíé Discord Nitro Classic",
            _ => "üíé Premium",
        };
        embed = embed.field("üíé subscription", nitro_type, true);
    }

    if let Some(accent_color) = full_user.accent_colour {
        let color_hex = format!("#{:06X}", accent_color.0);
        embed = embed.field("üé® accent color", format!("**`{}`**", color_hex), true);
    }

    if let Some(member) = member_info {
        if let Some(joined_at) = member.joined_at {
            let join_info = format!(
                "<t:{}:F> (<t:{}:R>)",
                joined_at.timestamp(),
                joined_at.timestamp()
            );
            embed = embed.field("üì• joined server", join_info, false);
        }

        let roles: Vec<String> = member
            .roles
            .iter()
            .filter_map(|role_id| {
                if let Some(guild) = ctx.guild() {
                    guild
                        .roles
                        .get(role_id)
                        .map(|role| format!("<@&{}>", role.id))
                } else {
                    None
                }
            })
            .collect();

        if !roles.is_empty() {
            let roles_text = roles.join(" ");
            embed = embed.field(&format!("üé≠ roles: `{}`", roles.len()), roles_text, false);
        }

        if let Some(premium_since) = member.premium_since {
            embed = embed.field(
                "üíé boosting",
                format!("since <t:{}:R>", premium_since.timestamp()),
                true,
            );
        }

        if let Some(timed_out_until) = member.communication_disabled_until {
            if timed_out_until > serenity::Timestamp::now() {
                embed = embed.field(
                    "‚è∞ timed out",
                    format!("until <t:{}:R>", timed_out_until.timestamp()),
                    true,
                );
            }
        }

        if let Some(nick) = &member.nick {
            embed = embed.field("üìù server nickname", format!("**`{}`**", nick), true);
        }

        if member.pending {
            embed = embed.field("‚è≥ membership pending", "yes", true);
        }

        if member.deaf {
            embed = embed.field("üîá server deafened", "yes", true);
        }

        if member.mute {
            embed = embed.field("üîá server muted", "yes", true);
        }

        if let Some(avatar) = &member.avatar {
            let server_avatar_url = format!(
                "https://cdn.discordapp.com/guilds/{}/users/{}/avatars/{}.png?size=1024",
                ctx.guild_id().unwrap(),
                target_user.id,
                avatar
            );
            embed = embed.field(
                "üñºÔ∏è server avatar",
                format!("[View Avatar]({})", server_avatar_url),
                true,
            );
        }
    }

    embed = embed.field("üè∑Ô∏è user id", format!("`{}`", target_user.id), true);

    embed = embed.thumbnail(target_user.face());

    if let Some(banner_url) = full_user.banner_url() {
        embed = embed.image(banner_url);
    }

    embed = embed.timestamp(serenity::Timestamp::now());

    ctx.send(poise::CreateReply::default().embed(embed)).await?;
    Ok(())
}

#[poise::command(slash_command)]
pub async fn role(
    ctx: Context<'_>,
    #[description = "Role to get information about"] role: serenity::Role,
) -> Result<(), Error> {
    if ctx.guild_id().is_none() {
        ctx.send(
            poise::CreateReply::default()
                .content("‚ùå this command can only be used in a server!")
                .ephemeral(true),
        )
        .await?;
        return Ok(());
    }

    let created_at = role.id.created_at();
    let created_timestamp = format!(
        "<t:{}:F> (<t:{}:R>)",
        created_at.timestamp(),
        created_at.timestamp()
    );

    let member_count = if let Some(guild) = ctx.guild() {
        guild
            .members
            .values()
            .filter(|member| member.roles.contains(&role.id))
            .count()
    } else {
        0
    };

    let permissions_list = if role.permissions.is_empty() {
        "None".to_string()
    } else {
        let mut perms = Vec::new();

        if role.permissions.administrator() {
            perms.push("üëë Administrator");
        } else {
            if role.permissions.manage_guild() {
                perms.push("‚öôÔ∏è Manage Server");
            }
            if role.permissions.manage_roles() {
                perms.push("üé≠ Manage Roles");
            }
            if role.permissions.manage_channels() {
                perms.push("üí¨ Manage Channels");
            }
            if role.permissions.kick_members() {
                perms.push("ü¶∂ Kick Members");
            }
            if role.permissions.ban_members() {
                perms.push("üî® Ban Members");
            }
            if role.permissions.moderate_members() {
                perms.push("‚è∞ Timeout Members");
            }
            if role.permissions.manage_messages() {
                perms.push("üóëÔ∏è Manage Messages");
            }
            if role.permissions.mention_everyone() {
                perms.push("üì¢ Mention Everyone");
            }
            if role.permissions.view_audit_log() {
                perms.push("üìã View Audit Log");
            }
            if role.permissions.manage_webhooks() {
                perms.push("üîó Manage Webhooks");
            }
            if role.permissions.manage_guild_expressions() {
                perms.push("üòÄ Manage Emojis");
            }
            if role.permissions.create_instant_invite() {
                perms.push("üìé Create Invites");
            }
            if role.permissions.manage_events() {
                perms.push("üìÖ Manage Events");
            }
        }

        if perms.len() > 6 {
            format!("{} and {} more", perms[..6].join(", "), perms.len() - 6)
        } else if perms.is_empty() {
            "Basic permissions only".to_string()
        } else {
            perms.join(", ")
        }
    };

    let role_type = if role.managed {
        let tags = &role.tags;
        if tags.bot_id.is_some() {
            "ü§ñ Bot Role"
        } else if tags.integration_id.is_some() {
            "üîó Integration Role"
        } else if tags.premium_subscriber {
            "üíé Booster Role"
        } else if tags.subscription_listing_id.is_some() {
            "üí∞ Subscription Role"
        } else if tags.available_for_purchase {
            "üõí Purchasable Role"
        } else if tags.guild_connections {
            "üîó Linked Role"
        } else {
            "‚öôÔ∏è Managed Role"
        }
    } else {
        "üë§ Regular Role"
    };

    let mut embed = CreateEmbed::new()
        .title(&format!("üé≠ `{}` info", role.name))
        .description(format!("<@&{}> `{}`", role.id, role.id))
        .color(role.colour)
        .field("üë• members", format!("**`{}`**", member_count), true)
        .field("üìç position", format!("**`{}`**", role.position), true)
        .field("üè∑Ô∏è type", role_type, true)
        .field("üìÖ created", created_timestamp, false);

    if role.hoist {
        embed = embed.field("üìã displayed separately", "**yes**", true);
    } else {
        embed = embed.field("üìã displayed separately", "**no**", true);
    }

    if role.mentionable {
        embed = embed.field("üì¢ mentionable", "**yes**", true);
    }

    if role.colour != serenity::Colour::default() {
        let color_hex = format!("#{:06X}", role.colour.0);
        embed = embed.field("üé® color", format!("**`{}`**", color_hex), true);
    }

    if let Some(icon) = &role.icon {
        let icon_url = format!(
            "https://cdn.discordapp.com/role-icons/{}/{}.png",
            role.id, icon
        );
        embed = embed.thumbnail(icon_url);
    }

    if let Some(emoji) = &role.unicode_emoji {
        embed = embed.field("üòÄ emoji", emoji, true);
    }

    let tags = &role.tags;
    if let Some(bot_id) = tags.bot_id {
        embed = embed.field("ü§ñ bot", format!("<@{}>", bot_id), true);
    }

    if let Some(integration_id) = tags.integration_id {
        embed = embed.field("üîó integration id", format!("`{}`", integration_id), true);
    }

    if let Some(subscription_id) = tags.subscription_listing_id {
        embed = embed.field("üí∞ subscription id", format!("`{}`", subscription_id), true);
    }

    if tags.available_for_purchase {
        embed = embed.field("üõí available for purchase", "**yes**", true);
    }

    if tags.guild_connections {
        embed = embed.field("üîó linked role", "**yes**", true);
    }

    embed = embed.field("üîê key permissions", permissions_list, false);

    embed = embed.field("üè∑Ô∏è role id", format!("`{}`", role.id), true);

    embed = embed.field("üè∞ guild id", format!("`{}`", role.guild_id), true);

    embed = embed.timestamp(serenity::Timestamp::now());

    ctx.send(poise::CreateReply::default().embed(embed)).await?;
    Ok(())
}

#[poise::command(slash_command)]
pub async fn channel(
    ctx: Context<'_>,
    #[description = "Channel to get information about"] channel: Option<serenity::GuildChannel>,
) -> Result<(), Error> {
    if ctx.guild_id().is_none() {
        ctx.send(
            poise::CreateReply::default()
                .content("‚ùå this command can only be used in a server!")
                .ephemeral(true),
        )
        .await?;
        return Ok(());
    }

    let target_channel = match channel {
        Some(ch) => ch,
        None => match ctx.channel_id().to_channel(&ctx.http()).await {
            Ok(serenity::Channel::Guild(guild_channel)) => guild_channel,
            _ => {
                ctx.send(
                    poise::CreateReply::default()
                        .content("‚ùå could not get channel information!")
                        .ephemeral(true),
                )
                .await?;
                return Ok(());
            }
        },
    };

    let created_at = target_channel.id.created_at();
    let created_timestamp = format!(
        "<t:{}:F> (<t:{}:R>)",
        created_at.timestamp(),
        created_at.timestamp()
    );

    let channel_type = match target_channel.kind {
        serenity::ChannelType::Text => "üìù Text Channel",
        serenity::ChannelType::Voice => "üîä Voice Channel",
        serenity::ChannelType::Category => "üìÅ Category",
        serenity::ChannelType::News => "üì∞ Announcement Channel",
        serenity::ChannelType::Stage => "üéôÔ∏è Stage Channel",
        serenity::ChannelType::Forum => "üí¨ Forum Channel",
        serenity::ChannelType::PublicThread => "üßµ Public Thread",
        serenity::ChannelType::PrivateThread => "üîí Private Thread",
        serenity::ChannelType::NewsThread => "üì∞ News Thread",
        _ => "‚ùì Unknown Channel Type",
    };

    let mut embed = CreateEmbed::new()
        .title(&format!(
            "{} `{}` info",
            match target_channel.kind {
                serenity::ChannelType::Text => "üìù",
                serenity::ChannelType::Voice => "üîä",
                serenity::ChannelType::Category => "üìÅ",
                serenity::ChannelType::News => "üì∞",
                serenity::ChannelType::Stage => "üéôÔ∏è",
                serenity::ChannelType::Forum => "üí¨",
                _ => "üí¨",
            },
            target_channel.name
        ))
        .description(format!("<#{}> `{}`", target_channel.id, target_channel.id))
        .color(get_default_embed_color(ctx.data()))
        .field("üè∑Ô∏è type", channel_type, true)
        .field(
            "üìç position",
            format!("**`{}`**", target_channel.position),
            true,
        )
        .field("üìÖ created", created_timestamp, false);

    embed = embed.field(
        "üè∞ guild id",
        format!("`{}`", target_channel.guild_id),
        true,
    );

    if let Some(topic) = &target_channel.topic {
        if !topic.is_empty() {
            let display_topic = if topic.len() > 100 {
                format!("{}...", &topic[..97])
            } else {
                topic.clone()
            };
            embed = embed.field("üìã description", format!("*{}*", display_topic), false);
        }
    }

    if let Some(parent_id) = target_channel.parent_id {
        if let Ok(parent) = parent_id.to_channel(&ctx.http()).await {
            if let serenity::Channel::Guild(parent_channel) = parent {
                embed = embed.field(
                    "üìÅ category",
                    format!("`{}`\n**{}**", parent_channel.id, parent_channel.name),
                    true,
                );
            }
        } else {
            embed = embed.field("üìÅ parent channel", format!("<#{}>", parent_id), true);
        }
    }

    if target_channel.nsfw {
        embed = embed.field("üîû NSFW", "**yes**", true);
    }

    match target_channel.kind {
        serenity::ChannelType::Text | serenity::ChannelType::News => {
            if let Some(slowmode) = target_channel.rate_limit_per_user {
                if slowmode > 0 {
                    embed = embed.field("‚è∞ slowmode", format!("**{}s**", slowmode), true);
                }
            }

            if let Some(last_message_id) = target_channel.last_message_id {
                embed = embed.field(
                    "üí¨ last message",
                    format!("<t:{}:R>", last_message_id.created_at().timestamp()),
                    true,
                );
            }

            if let Some(last_pin_timestamp) = target_channel.last_pin_timestamp {
                embed = embed.field(
                    "üìå last pin",
                    format!("<t:{}:R>", last_pin_timestamp.timestamp()),
                    true,
                );
            }

            if let Some(default_auto_archive_duration) =
                target_channel.default_auto_archive_duration
            {
                let duration = match default_auto_archive_duration {
                    serenity::AutoArchiveDuration::OneHour => "1 hour",
                    serenity::AutoArchiveDuration::OneDay => "24 hours",
                    serenity::AutoArchiveDuration::ThreeDays => "3 days",
                    serenity::AutoArchiveDuration::OneWeek => "1 week",
                    _ => "custom",
                };
                embed = embed.field("üóìÔ∏è auto archive", format!("**{}**", duration), true);
            }
        }
        serenity::ChannelType::Voice | serenity::ChannelType::Stage => {
            if let Some(bitrate) = target_channel.bitrate {
                embed = embed.field("üéµ bitrate", format!("**{}kbps**", bitrate / 1000), true);
            }

            if let Some(user_limit) = target_channel.user_limit {
                if user_limit > 0 {
                    embed = embed.field("üë• user limit", format!("**{}**", user_limit), true);
                } else {
                    embed = embed.field("üë• user limit", "**unlimited**", true);
                }
            }

            if let Some(rtc_region) = &target_channel.rtc_region {
                embed = embed.field("üåç region", format!("**{}**", rtc_region), true);
            }

            if let Some(video_quality_mode) = target_channel.video_quality_mode {
                let quality = match video_quality_mode {
                    serenity::VideoQualityMode::Auto => "Auto",
                    serenity::VideoQualityMode::Full => "720p",
                    _ => "Unknown",
                };
                embed = embed.field("üé• video quality", format!("**{}**", quality), true);
            }
        }
        serenity::ChannelType::Forum => {
            if let Some(slowmode) = target_channel.rate_limit_per_user {
                if slowmode > 0 {
                    embed = embed.field("‚è∞ slowmode", format!("**{}s**", slowmode), true);
                }
            }

            let tags = &target_channel.available_tags;
            if !tags.is_empty() {
                let tag_count = tags.len();
                let tag_names: Vec<String> = tags
                    .iter()
                    .take(5)
                    .map(|tag| {
                        if let Some(emoji) = &tag.emoji {
                            match emoji {
                                serenity::ForumEmoji::Name(unicode) => {
                                    format!("{} {}", unicode, tag.name)
                                }
                                serenity::ForumEmoji::Id(id) => {
                                    format!("<:tag:{}> {}", id, tag.name)
                                }
                                _ => tag.name.clone(),
                            }
                        } else {
                            tag.name.clone()
                        }
                    })
                    .collect();

                let display_tags = if tags.len() > 5 {
                    format!("{} (+{} more)", tag_names.join(", "), tags.len() - 5)
                } else {
                    tag_names.join(", ")
                };

                embed = embed.field(&format!("üè∑Ô∏è tags ({})", tag_count), display_tags, false);
            }

            if let Some(default_reaction_emoji) = &target_channel.default_reaction_emoji {
                let emoji_display = match default_reaction_emoji {
                    serenity::ForumEmoji::Name(unicode) => unicode.clone(),
                    serenity::ForumEmoji::Id(id) => format!("<:reaction:{}>", id),
                    _ => "Unknown".to_string(),
                };
                embed = embed.field("üòÄ default reaction", emoji_display, true);
            }

            if let Some(default_thread_rate_limit) =
                target_channel.default_thread_rate_limit_per_user
            {
                if default_thread_rate_limit > 0 {
                    embed = embed.field(
                        "üßµ thread slowmode",
                        format!("**{}s**", default_thread_rate_limit),
                        true,
                    );
                }
            }

            if let Some(default_sort_order) = target_channel.default_sort_order {
                let sort_name = match default_sort_order {
                    serenity::SortOrder::LatestActivity => "Latest Activity",
                    serenity::SortOrder::CreationDate => "Creation Date",
                    _ => "Unknown",
                };
                embed = embed.field("üîÑ default sort", format!("**{}**", sort_name), true);
            }

            if let Some(default_forum_layout) = target_channel.default_forum_layout {
                let layout_name = match default_forum_layout {
                    serenity::ForumLayoutType::NotSet => "Not Set",
                    serenity::ForumLayoutType::ListView => "List View",
                    serenity::ForumLayoutType::GalleryView => "Gallery View",
                    _ => "Unknown",
                };
                embed = embed.field("üó∫Ô∏è layout", format!("**{}**", layout_name), true);
            }
        }
        serenity::ChannelType::PublicThread
        | serenity::ChannelType::PrivateThread
        | serenity::ChannelType::NewsThread => {
            if let Some(thread_metadata) = &target_channel.thread_metadata {
                if thread_metadata.archived {
                    embed = embed.field("üóÑÔ∏è archived", "**yes**", true);

                    if let Some(archive_timestamp) = thread_metadata.archive_timestamp {
                        embed = embed.field(
                            "üóìÔ∏è archived at",
                            format!("<t:{}:R>", archive_timestamp.timestamp()),
                            true,
                        );
                    }
                }

                if thread_metadata.locked {
                    embed = embed.field("üîí locked", "**yes**", true);
                }

                let duration = match thread_metadata.auto_archive_duration {
                    serenity::AutoArchiveDuration::OneHour => "1 hour",
                    serenity::AutoArchiveDuration::OneDay => "24 hours",
                    serenity::AutoArchiveDuration::ThreeDays => "3 days",
                    serenity::AutoArchiveDuration::OneWeek => "1 week",
                    _ => "custom",
                };
                embed = embed.field("‚è∞ auto archive", format!("**{}**", duration), true);

                if thread_metadata.invitable {
                    embed = embed.field("üì´ invitable", "**yes**", true);
                }
            }

            if let Some(owner_id) = target_channel.owner_id {
                embed = embed.field("üëë thread creator", format!("<@{}>", owner_id), true);
            }

            if let Some(message_count) = target_channel.message_count {
                embed = embed.field("üí¨ message count", format!("**~{}**", message_count), true);
            }

            if let Some(member_count) = target_channel.member_count {
                embed = embed.field("üë• member count", format!("**~{}**", member_count), true);
            }

            if let Some(total_message_sent) = target_channel.total_message_sent {
                embed = embed.field(
                    "üì® total messages",
                    format!("**{}**", total_message_sent),
                    true,
                );
            }
        }
        _ => {}
    }

    let permission_overwrites = target_channel.permission_overwrites.len();
    if permission_overwrites > 0 {
        let mut overwrite_details = Vec::new();
        for overwrite in &target_channel.permission_overwrites {
            match overwrite.kind {
                serenity::PermissionOverwriteType::Role(role_id) => {
                    overwrite_details.push(format!("Role <@&{}>", role_id));
                }
                serenity::PermissionOverwriteType::Member(user_id) => {
                    overwrite_details.push(format!("User <@{}>", user_id));
                }
                _ => {}
            }
        }

        let overwrite_text = if overwrite_details.len() > 3 {
            format!(
                "{} (+{} more)",
                overwrite_details[..3].join(", "),
                overwrite_details.len() - 3
            )
        } else {
            overwrite_details.join(", ")
        };

        if !overwrite_text.is_empty() {
            embed = embed.field(
                "üîê permission overwrites",
                format!("**`{}`**\n{}", permission_overwrites, overwrite_text),
                false,
            );
        } else {
            embed = embed.field(
                "üîê permission overwrites",
                format!("**`{}`**", permission_overwrites),
                true,
            );
        }
    }

    let flags = target_channel.flags;
    let mut flag_list = Vec::new();
    if flags.contains(serenity::ChannelFlags::PINNED) {
        flag_list.push("üìå Pinned");
    }
    if flags.contains(serenity::ChannelFlags::REQUIRE_TAG) {
        flag_list.push("üè∑Ô∏è Requires Tag");
    }

    if !flag_list.is_empty() {
        embed = embed.field("üè¥ flags", flag_list.join(", "), true);
    }

    embed = embed.timestamp(serenity::Timestamp::now());

    ctx.send(poise::CreateReply::default().embed(embed)).await?;
    Ok(())
}
